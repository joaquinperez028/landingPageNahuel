import { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '../../../lib/googleAuth';
import dbConnect from '../../../lib/mongodb';
import Report from '../../../models/Report';
import User from '../../../models/User';
import { getCloudinaryImageUrl, CloudinaryUploadResult } from '../../../lib/cloudinary';
import { createReportNotification } from '../../../lib/notificationUtils';

// Definir interface para las im√°genes procesadas
interface ProcessedImage {
  public_id: string;
  url: string;
  secure_url: string;
  width: number;
  height: number;
  format: string;
  bytes: number;
  caption: string;
  order: number;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'M√©todo no permitido' });
  }

  try {
    // Verificar autenticaci√≥n
    const session = await getServerSession(req, res, authOptions);
    if (!session?.user?.email) {
      return res.status(401).json({ message: 'No autorizado' });
    }

    await dbConnect();

    // Verificar que el usuario existe y es admin
    const user = await User.findOne({ email: session.user.email });
    if (!user) {
      return res.status(404).json({ message: 'Usuario no encontrado' });
    }

    if (user.role !== 'admin') {
      return res.status(403).json({ 
        message: 'Solo los administradores pueden crear informes' 
      });
    }

    const { 
      title, 
      content, 
      type, 
      category,
      summary,
      readTime,
      tags,
      isFeature,
      coverImage, 
      images,
      articles // Agregar campo de art√≠culos
    } = req.body;

    // Validar datos requeridos
    if (!title || !content) {
      return res.status(400).json({ 
        message: 'T√≠tulo y contenido son requeridos' 
      });
    }

    // Validar tiempo de lectura
    if (!readTime || isNaN(parseInt(readTime))) {
      return res.status(400).json({
        message: 'Tiempo de lectura es requerido y debe ser un n√∫mero v√°lido'
      });
    }

    // Validar art√≠culos si se proporcionan
    if (articles && Array.isArray(articles)) {
      console.log('üìö [API CREATE] Validando art√≠culos:', articles.length);
      
      if (articles.length > 10) {
        return res.status(400).json({
          message: 'Un informe no puede tener m√°s de 10 art√≠culos'
        });
      }

      // Validar cada art√≠culo
      for (const article of articles) {
        if (!article.title || !article.content || !article.order) {
          console.log('‚ùå [API CREATE] Art√≠culo inv√°lido:', article);
          return res.status(400).json({
            message: 'Cada art√≠culo debe tener t√≠tulo, contenido y orden'
          });
        }
        if (article.order < 1 || article.order > 10) {
          return res.status(400).json({
            message: 'El orden de los art√≠culos debe estar entre 1 y 10'
          });
        }
      }
    } else {
      console.log('‚ö†Ô∏è [API CREATE] No se recibieron art√≠culos o no es un array');
    }

    console.log('üìù Creando nuevo informe:', {
      title,
      type,
      category,
      summary,
      readTime,
      hasCoverImage: !!coverImage,
      imagesCount: images?.length || 0,
      articlesCount: articles?.length || 0,
      author: user.email
    });

    // Procesar imagen de portada
    let processedCoverImage: ProcessedImage | null = null;
    if (coverImage && coverImage.public_id) {
      processedCoverImage = {
        public_id: coverImage.public_id,
        url: coverImage.secure_url || coverImage.url,
        secure_url: coverImage.secure_url || coverImage.url,
        width: coverImage.width,
        height: coverImage.height,
        format: coverImage.format,
        bytes: coverImage.bytes,
        caption: coverImage.caption || '',
        order: 0
      };

      console.log('üñºÔ∏è Imagen de portada procesada:', processedCoverImage.public_id);
    }

    // Procesar im√°genes adicionales
    let processedImages: ProcessedImage[] = [];
    if (images && Array.isArray(images)) {
      processedImages = images.map((img: any, index: number): ProcessedImage => ({
        public_id: img.public_id,
        url: img.secure_url || img.url,
        secure_url: img.secure_url || img.url,
        width: img.width,
        height: img.height,
        format: img.format,
        bytes: img.bytes,
        caption: img.caption || '',
        order: index + 1
      }));

      console.log('üì∏ Im√°genes adicionales procesadas:', processedImages.length);
    }

    // Crear el informe
    const newReport = new Report({
      title,
      content,
      summary: summary || '',
      readTime: parseInt(readTime),
      author: user._id,
      type: type || 'text',
      category: category || 'general',
      coverImage: processedCoverImage,
      images: processedImages,
      tags: Array.isArray(tags) ? tags : [],
      isFeature: isFeature || false,
      articles: articles || [], // Incluir art√≠culos en el informe
      isPublished: true,
      publishedAt: new Date()
    });

    console.log('üìÑ [API CREATE] Informe a guardar:', {
      title: newReport.title,
      hasArticles: !!newReport.articles,
      articlesCount: newReport.articles?.length || 0,
      articles: newReport.articles
    });

    const savedReport = await newReport.save();

    console.log('‚úÖ Informe creado exitosamente:', savedReport._id);
    console.log('üìö [API CREATE] Art√≠culos guardados:', savedReport.articles?.length || 0);
    if (savedReport.articles && savedReport.articles.length > 0) {
      console.log('üìã [API CREATE] Detalles de art√≠culos guardados:', savedReport.articles.map((article: any) => ({
        title: article.title,
        order: article.order,
        isPublished: article.isPublished
      })));
    }

    // üì∞ NUEVA FUNCIONALIDAD: Crear notificaci√≥n autom√°tica
    try {
      await createReportNotification(savedReport);
      console.log('‚úÖ Notificaci√≥n autom√°tica enviada para informe:', savedReport._id);
    } catch (notificationError) {
      console.error('‚ùå Error al enviar notificaci√≥n autom√°tica:', notificationError);
      // No fallar la creaci√≥n del informe si la notificaci√≥n falla
    }

    // Poblar datos del autor para la respuesta
    await savedReport.populate('author', 'name email');

    // Generar URLs optimizadas para Cloudinary
    const responseData = {
      ...savedReport.toJSON(),
      // URL de imagen de portada optimizada
      imageUrl: processedCoverImage ? 
        getCloudinaryImageUrl(processedCoverImage.public_id, {
          width: 800,
          height: 600,
          crop: 'fill',
          format: 'webp'
        }) : null,
      // URLs de im√°genes adicionales optimizadas
      optimizedImages: processedImages.map((img: ProcessedImage) => ({
        ...img,
        optimizedUrl: getCloudinaryImageUrl(img.public_id, {
          width: 800,
          height: 600,
          crop: 'fill',
          format: 'webp'
        })
      }))
    };

    return res.status(201).json({
      success: true,
      message: 'Informe creado exitosamente',
      data: {
        report: responseData
      }
    });

  } catch (error) {
    console.error('‚ùå Error creando informe:', error);
    return res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error instanceof Error ? error.message : 'Error desconocido'
    });
  }
} 